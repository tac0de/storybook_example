# 실전 React 마스터 과정: 엄격한 ESLint와 Storybook으로 배우는 전문가급 컴포넌트 개발

이 문서는 단순한 프로젝트 분석이 아닙니다. 이것은 프로덕션 레벨의 React 애플리케이션을 구축하는 데 필요한 사고방식과 기술적 원칙을 담은 가이드입니다. 우리는 "그냥 동작하는" 코드가 아닌, **깨끗하고, 유지보수 가능하며, 확장하기 쉬운** 코드를 작성하는 것을 목표로 합니다.

## 1. 우리의 개발 철학: 왜 이렇게 엄격해야 하는가?

이 프로젝트는 ESLint, TypeScript, Storybook이라는 세 가지 강력한 도구를 중심으로 구축되었습니다. 이 도구들은 제약이 아니라, 여러분을 더 나은 개발자로 만들어 줄 가드레일입니다.

- **ESLint: 당신의 첫 번째 코드 리뷰어**
  - **역할**: ESLint는 단순한 문법 검사기가 아닙니다. 팀 전체의 코딩 스타일을 일관되게 유지하고, 잠재적인 버그와 안티패턴을 코드가 커밋되기도 전에 찾아내는 자동화된 시니어 개발자입니다. `eslint.config.mjs`에 정의된 규칙들은 수많은 개발 경험에서 비롯된 모범 사례(Best Practice)의 집약체입니다.
  - **학습 목표**: "왜 이 규칙이 필요할까?"를 항상 질문하며, 규칙이 강제하는 더 나은 코딩 습관을 체득해야 합니다.

- **TypeScript: 최고의 문서이자 가장 든든한 안전망**
  - **역할**: TypeScript는 코드에 타입을 명시함으로써 "계약"을 만듭니다. `CommentItemProps` 인터페이스는 `CommentItem` 컴포넌트와 외부 세계 간의 약속입니다. 이 약속 덕분에 우리는 컴파일 시점에 실수를 잡고, 더욱 안전하게 리팩토링하며, VSCode와 같은 에디터에서 완벽한 자동완성 기능을 누릴 수 있습니다.
  - **학습 목표**: 타입을 귀찮은 추가 작업으로 여기지 말고, 미래의 버그를 예방하고 동료와의 협업을 원활하게 만드는 가장 중요한 도구로 인식해야 합니다.

- **Storybook: 살아있는 디자인 시스템이자 완벽한 실험실**
  - **역할**: Storybook은 단순히 컴포넌트를 시각적으로 확인하는 곳이 아닙니다. 이곳은 우리 애플리케이션의 모든 UI 조각들이 살아 숨 쉬는 "디자인 시스템의 명세서"입니다. 각 컴포넌트의 모든 상태(state)와 상호작용(interaction)을 독립적으로 테스트하고 문서화함으로써, 우리는 전체 앱을 실행할 필요 없이 UI의 견고함을 보장할 수 있습니다.
  - **학습 목표**: 컴포넌트를 만들 때마다 해당 컴포넌트가 가질 수 있는 모든 시나리오(예: 로딩, 에러, 비활성화, 텍스트 길이 초과 등)를 Storybook에서 구현하는 습관을 들여야 합니다.

## 2. 아토믹 디자인: 레고를 넘어, 시스템을 설계하다

`src/components`의 구조는 아토믹 디자인 원칙을 따릅니다. 이것은 단순히 폴더를 나누는 규칙이 아니라, UI를 체계적으로 조립하고 확장하기 위한 설계 철학입니다.

- **`Atoms` (원자)**: **절대적으로 순수해야 합니다.** `Atom`은 자신만의 상태(state)를 가져서는 안 되며, 오직 `props`를 통해서만 제어되어야 합니다. `Button`은 자신이 "primary"인지 "danger"인지 스스로 결정하지 않습니다. 외부에서 `variant` prop으로 주입받을 뿐입니다. 이것이 재사용성의 핵심입니다.

- **`Molecules` (분자)**: **컨텍스트를 갖기 시작하는 단위.** `Atom`들을 조합하여 구체적인 목적을 가집니다. `CommentItem`은 `Avatar`, `Button` 등의 `Atom`에 실제 데이터를 `props`로 전달하며 의미 있는 단위로 만듭니다.

- **`Organisms` (유기체)**: **비즈니스 로직과 상태가 주입되는 곳.** `CommentList`는 `comments`라는 상태를 가지며, 이 데이터를 각 `CommentItem`에 전달하고, `onDelete`와 같은 이벤트를 처리하는 역할을 담당합니다. 실제 애플리케이션의 기능이 구현되는 레벨입니다.

## 3. 전문가처럼 컴포넌트 개발하기: 실전 학습 포인트

- **1. Props는 "계약"이다: TypeScript 인터페이스 심층 분석**
  - `CommentItemProps`를 다시 봅시다. `readonly` 키워드는 이 컴포넌트 내부에서 `props`를 절대 수정해서는 안 된다는 불변성의 원칙을 강제합니다. `avatarUrl?: string`의 `?`는 이 `prop`이 선택적이라는 것을 명시하며, `onDelete?`는 이 컴포넌트가 삭제 기능을 가질 수도, 가지지 않을 수도 있음을 의미합니다. 이 모든 것이 코드의 의도를 명확하게 만드는 계약서의 조항들입니다.

- **2. Storybook으로 모든 시나리오 정복하기**
  - `Button.stories.tsx`를 보면, 단순히 버튼을 나열하는 데 그치지 않습니다. `args`를 통해 각기 다른 `props`를 전달하여 `Primary`, `Danger`, `Small` 등 모든 시각적 변형(variant)을 테스트합니다. 전문가는 여기서 한 걸음 더 나아가, `play` 함수를 사용하여 "버튼을 클릭했을 때 `onClick` 핸들러가 호출되는가?"와 같은 상호작용까지 테스트합니다.

- **3. CSS Modules: 스타일 충돌은 과거의 유물**
  - `styles.commentItem`과 같은 문법은 CSS를 JavaScript 모듈처럼 다루게 해줍니다. Vite는 빌드 시점에 `_commentItem_aB3x1`과 같은 고유한 클래스 이름을 생성하여, 다른 컴포넌트의 스타일과 절대 충돌하지 않도록 보장합니다. 이것이 바로 대규모 애플리케이션에서 스타일을 안정적으로 관리하는 현대적인 방식입니다.

## 4. 실전 과제: 디자인 시스템 확장하기

이제 당신이 직접 이 시스템의 일부가 되어볼 차례입니다. 다음 과제를 통해 전문가의 개발 프로세스를 경험해보세요.

#### **과제 1: `Badge` Atom 컴포넌트 명세 및 구현**

1.  **요구사항 분석**: "New", "Updated" 등 작은 텍스트 정보를 시각적으로 강조하는 `Badge` 컴포넌트가 필요합니다. `success`, `warning`, `danger` 등의 색상 변형이 가능해야 합니다.
2.  **Props 설계 (`Badge.tsx`)**: `BadgeProps` 인터페이스를 정의하세요. (`children: React.ReactNode`, `variant: 'success' | 'warning' | 'danger'`).
3.  **컴포넌트 구현 (`Badge.tsx`, `Badge.module.scss`)**: `props`에 따라 다른 스타일을 적용하는 컴포넌트를 작성하세요.
4.  **스토리 작성 (`Badge.stories.tsx`)**: 모든 `variant`에 대한 스토리를 작성하여 Storybook에서 시각적으로 검증하세요.
5.  **단위 테스트 작성 (`Badge.test.tsx`)**: `Badge`가 올바른 텍스트와 클래스를 렌더링하는지 `vitest`로 테스트하세요.
6.  **코드 품질 검사**: `npm run lint` 명령을 실행하여 모든 ESLint 규칙을 통과하는지 확인하세요.

#### **과제 2: `CommentItem`에 `Badge` 통합**

1.  **요구사항 분석**: 새로운 댓글(`isNew`)일 경우, 작성자 이름 옆에 "New" `Badge`를 표시하고 싶습니다.
2.  **Props 확장 (`CommentItem.tsx`)**: `CommentItemProps`에 `isNew?: boolean` 속성을 추가하세요.
3.  **조건부 렌더링**: `isNew`가 `true`일 때만 `Badge` 컴포넌트가 렌더링되도록 `CommentItem.tsx`를 수정하세요.
4.  **스토리 업데이트 (`CommentItem.stories.tsx`)**: 기존 `CommentItem` 스토리에 `isNew` prop을 추가하여 "새 댓글" 시나리오를 Storybook에서 검증할 수 있도록 업데이트하세요.

## 결론

이 프로젝트는 React의 기술을 배우는 것을 넘어, **소프트웨어 장인정신(Software Craftsmanship)**을 훈련하는 과정입니다. 엄격한 규칙과 체계적인 구조 속에서, 우리는 더 안정적이고 예측 가능한 소프트웨어를 만드는 법을 배웁니다. 이 원칙들을 당신의 것으로 만들 때, 당신은 비로소 진정한 전문가로 거듭날 것입니다.