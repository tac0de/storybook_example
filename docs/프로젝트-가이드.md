# 🚀 Storybook 프로젝트 완전 가이드

> 프로그래밍을 처음 접하는 분들도 쉽게 따라할 수 있는 친절한 가이드입니다!

## 📖 프로젝트 개요

### 🤔 이 프로젝트가 뭔가요?

이 프로젝트는 웹사이트를 만들 때 사용하는 **재사용 가능한 부품들(컴포넌트)**을 모아놓은 라이브러리입니다. 

**쉽게 말하면:**
- 레고 블록처럼 조립해서 웹사이트를 만들 수 있는 부품들
- 버튼, 입력창, 헤더 등 웹사이트에서 자주 보는 요소들
- 한 번 만들어두면 여러 곳에서 재사용 가능

### 🛠️ 사용된 기술들

**React** 📱
- 웹사이트의 화면을 만드는 도구
- 페이스북에서 만든 인기 있는 기술

**TypeScript** 📝
- JavaScript에 타입을 추가한 언어
- 오타나 실수를 미리 잡아주는 똑똑한 도구

**Storybook** 📚
- 컴포넌트들을 시각적으로 확인하고 테스트하는 도구
- 실제 웹사이트에 적용하기 전에 미리 볼 수 있음

## 🏁 시작하기

### 📋 준비물 체크리스트

시작하기 전에 다음 프로그램들이 설치되어 있는지 확인해주세요:

- **Node.js** (버전 18 이상) - JavaScript 실행 환경
- **npm** - Node.js와 함께 자동 설치되는 패키지 관리자
- **코드 에디터** (VS Code 추천) - 코드를 작성하는 프로그램

### 1️⃣ 프로젝트 설치하기

**터미널이 뭔가요?** 🖥️
- 컴퓨터와 텍스트로 대화하는 창
- Windows: 명령 프롬프트 또는 PowerShell
- Mac: 터미널 앱

**설치 과정:**

1. 터미널을 열어주세요
2. 프로젝트 폴더로 이동하세요
3. 아래 명령어를 입력하고 Enter를 눌러주세요:

```bash
npm install
```

**이 명령어가 하는 일:**
- 프로젝트에 필요한 모든 라이브러리들을 자동으로 다운로드
- `node_modules` 폴더에 저장됨
- 인터넷 연결이 필요해요!

⏰ **예상 소요 시간:** 2-5분 (인터넷 속도에 따라)

### 2️⃣ Storybook 실행하기

**Storybook이 뭔가요?** 📚
- 컴포넌트들을 미리 볼 수 있는 전시관 같은 곳
- 실제 웹사이트에 적용하기 전에 테스트 가능

**실행 방법:**

```bash
npm run storybook
```

**성공하면 이런 메시지가 나와요:**
```
storybook v9.0.18
✓ Storybook 시작됨
➜ Local: http://localhost:3010/
```

**브라우저에서 확인하기:**
1. 웹 브라우저를 열어주세요 (Chrome, Safari, Firefox 등)
2. 주소창에 `http://localhost:3010` 입력
3. 짜잔! 🎉 Storybook이 열립니다

### 3️⃣ 개발 서버 실행하기 (선택사항)

**개발 서버가 뭔가요?** 🔧
- 실제 웹사이트처럼 작동하는 테스트 환경
- 코드를 수정하면 실시간으로 화면에 반영됨

```bash
npm run dev
```

**💡 팁:** Storybook과 개발 서버를 동시에 실행할 수 있어요!
- 터미널 창을 2개 열어서 각각 실행하면 됩니다

## 📁 프로젝트 구조 이해하기

### 🏠 폴더가 집이라면?

프로젝트 폴더 구조를 집에 비유해서 설명해드릴게요!

```
🏠 storybook_example/           # 우리 집 (프로젝트 루트)
├── 📦 package.json            # 집 설계도 (프로젝트 정보)
├── 🔧 node_modules/           # 도구창고 (라이브러리들)
├── 📚 docs/                   # 설명서 보관함
├── 🎨 public/                 # 공용 자료실 (이미지, 아이콘)
└── 🏗️ src/                    # 실제 작업 공간
    ├── 🧩 components/         # 레고 블록 보관함
    │   ├── ⚛️ Atoms/          # 가장 작은 부품들
    │   ├── 🔗 Molecules/      # 작은 부품들의 조합
    │   └── 🏢 Organisms/      # 큰 덩어리 부품들
    ├── 🎨 styles/             # 꾸미기 도구들
    └── 📷 assets/             # 개인 자료실
```

### 🧩 컴포넌트 폴더 자세히 알아보기

**Atomic Design 패턴** - 화학에서 영감을 받은 설계 방법!

#### ⚛️ Atoms (원자) - 가장 기본적인 부품
**예시:** 버튼, 입력창, 텍스트, 아이콘
```
Atoms/
├── Button/              # 버튼 컴포넌트
│   ├── Button.tsx       # 버튼 동작 코드
│   ├── Button.module.scss # 버튼 꾸미기
│   ├── Button.stories.tsx # 버튼 전시용
│   └── index.ts         # 내보내기 설정
└── Input/               # 입력창 컴포넌트
    ├── Input.tsx
    ├── Input.module.scss
    ├── Input.stories.tsx
    └── index.ts
```

**🤔 왜 이렇게 나누나요?**
- 한 번 만들면 여러 곳에서 재사용 가능
- 수정할 때 한 곳만 고치면 모든 곳에 적용
- 일관된 디자인 유지 가능

#### 🔗 Molecules (분자) - 원자들의 조합
**예시:** 검색바 (입력창 + 버튼), 카드 (이미지 + 텍스트 + 버튼)
```
Molecules/
├── SearchBar/           # 검색바 = 입력창 + 검색버튼
├── UserCard/            # 사용자 카드 = 아바타 + 이름 + 버튼
└── Navigation/          # 네비게이션 = 여러 링크들
```

#### 🏢 Organisms (유기체) - 복잡한 구조
**예시:** 헤더, 푸터, 사이드바
```
Organisms/
├── Header/              # 웹사이트 상단 전체
├── Footer/              # 웹사이트 하단 전체
└── Sidebar/             # 사이드 메뉴 전체
```

### 📄 파일 확장자 설명

- **`.tsx`** - TypeScript + React 코드 파일
- **`.scss`** - 스타일링 (꾸미기) 파일
- **`.stories.tsx`** - Storybook 전시용 파일
- **`index.ts`** - 다른 곳에서 쉽게 가져다 쓸 수 있게 하는 파일

### 🎨 styles 폴더
```
styles/
├── abstracts/           # 공통으로 쓰는 스타일 도구들
│   ├── _variables.scss  # 색상, 크기 등 설정값
│   ├── _mixins.scss     # 자주 쓰는 스타일 조합
│   └── _functions.scss  # 계산 도구들
└── index.scss           # 모든 스타일을 모아주는 파일
```

## 🎯 효율적인 코드 작성 가이드

### 🚀 처음부터 시작하는 컴포넌트 개발

**"어떻게 하면 좋은 컴포넌트를 만들 수 있을까요?"** 🤔

좋은 질문이에요! 차근차근 단계별로 알려드릴게요.

#### 1️⃣단계: 계획 수립 (가장 중요!) 📋

**🎯 목적 정하기**
- "이 컴포넌트가 뭘 하는 건가요?"
- "사용자가 이걸로 뭘 할 수 있나요?"
- 예시: "사용자가 클릭할 수 있는 버튼을 만들거예요"

**🔧 기능 정하기**
- "어떤 기능들이 필요한가요?"
- "어떤 모양들이 필요한가요?"
- 예시: "빨간색, 파란색, 회색 버튼이 필요해요"

**📏 크기 정하기**
- "작은 버튼, 보통 버튼, 큰 버튼이 필요해요"

**🏗️ 어디에 속하나요?**
- **Atoms**: 혼자서도 의미가 있는 것 (버튼, 입력창)
- **Molecules**: 여러 개가 모여야 의미가 있는 것 (검색바)
- **Organisms**: 페이지의 큰 부분 (헤더, 푸터)

**💡 팁:** 종이에 그려보세요! 머릿속 생각을 그림으로 그리면 더 명확해져요.

#### 2️⃣단계: 기본 구조 생성 (폴더와 파일 만들기) 📁

**"폴더와 파일을 어떻게 만드나요?"** 🤔

**방법 1: 터미널 사용하기 (개발자스럽게!)**
```bash
# 예시: Button 컴포넌트 생성
mkdir -p src/components/Atoms/Button    # 폴더 만들기
cd src/components/Atoms/Button          # 폴더로 이동

# 필요한 파일들 생성
touch Button.tsx Button.module.scss Button.stories.tsx index.ts
```

**방법 2: VS Code에서 직접 만들기 (쉬운 방법!)**
1. VS Code에서 `src/components/Atoms` 폴더를 우클릭
2. "New Folder" 선택 → "Button" 입력
3. Button 폴더를 우클릭 → "New File" 선택
4. 다음 파일들을 하나씩 만들어주세요:
   - `Button.tsx`
   - `Button.module.scss`
   - `Button.stories.tsx`
   - `index.ts`

**🤔 각 파일이 뭘 하는 건가요?**
- **Button.tsx**: 버튼의 동작과 모양을 정의
- **Button.module.scss**: 버튼을 예쁘게 꾸미는 스타일
- **Button.stories.tsx**: Storybook에서 버튼을 보여주는 설정
- **index.ts**: 다른 곳에서 버튼을 쉽게 가져다 쓸 수 있게 하는 파일

#### 3️⃣단계: TypeScript 인터페이스 먼저 작성 (설계도 그리기) 📐

**"인터페이스가 뭔가요?"** 🤔
- 컴포넌트가 받을 수 있는 정보들의 목록
- 건물을 짓기 전에 설계도를 그리는 것과 같아요!
- 미리 정해두면 실수를 줄일 수 있어요

**Button.tsx 파일을 열고 이 코드를 입력해주세요:**
```typescript
// Button.tsx
export interface ButtonProps {
  children: React.ReactNode;     // 버튼 안에 들어갈 텍스트나 내용
  variant?: 'primary' | 'secondary' | 'danger';  // 버튼 종류 (선택사항)
  size?: 'sm' | 'md' | 'lg';     // 버튼 크기 (선택사항)
  disabled?: boolean;            // 비활성화 여부 (선택사항)
  onClick?: () => void;          // 클릭했을 때 실행할 함수 (선택사항)
}
```

**🔍 코드 해석:**
- **children**: 버튼 안에 "확인", "취소" 같은 텍스트가 들어가요
- **variant**: 버튼의 색깔/스타일 (primary=파란색, secondary=회색, danger=빨간색)
- **size**: 버튼 크기 (sm=작게, md=보통, lg=크게)
- **disabled**: true면 클릭 안됨, false면 클릭 가능
- **onClick**: 버튼을 클릭했을 때 뭘 할지 정하는 함수
- **?** 표시: 꼭 필요하지 않은 선택사항이에요!

#### 4️⃣단계: 기본 컴포넌트 구조 작성 (실제 버튼 만들기) ⚙️

**"이제 진짜 버튼을 만들어볼까요?"** 🎉

**Button.tsx 파일에 이어서 이 코드를 추가해주세요:**
```typescript
// Button.tsx 계속
import React from 'react';                    // React 가져오기
import cx from 'classnames';                  // 클래스 조합 도구
import styles from './Button.module.scss';    // 스타일 파일 가져오기

export const Button: React.FC<ButtonProps> = ({
  children,                    // 버튼 안 내용
  variant = 'primary',         // 기본값: primary (파란색)
  size = 'md',                // 기본값: md (보통 크기)
  disabled = false,           // 기본값: false (활성화)
  onClick                     // 클릭 함수
}) => {
  return (
    <button
      className={cx(styles.button, styles[variant], styles[size])}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
};
```

**🔍 코드 해석:**
- **import**: 필요한 것들을 가져와요 (React, classnames, 스타일)
- **cx**: 여러 CSS 클래스를 깔끔하게 조합해주는 도구예요
- **export const Button**: 버튼 컴포넌트를 만들고 내보내요
- **= ({...})**: 위에서 정한 설계도(interface)대로 정보를 받아요
- **= 'primary'**: 기본값을 정해요 (아무것도 안 주면 이걸 써요)
- **className**: CSS 클래스를 조합해서 스타일을 적용해요
- **{children}**: 버튼 안에 텍스트를 넣어요

#### 5️⃣단계: 스타일 작성 (버튼을 예쁘게 꾸미기) 🎨

**"이제 버튼을 예쁘게 꾸며볼까요?"** ✨

**Button.module.scss 파일을 열고 이 코드를 입력해주세요:**
```scss
// Button.module.scss
.button {
  border: none;                    // 테두리 없애기
  border-radius: 4px;              // 모서리 둥글게
  cursor: pointer;                 // 마우스 올리면 손가락 모양
  font-weight: 500;                // 글자 두께 (조금 굵게)
  transition: all 0.2s ease;       // 부드러운 애니메이션 효과
  
  &:disabled {                     // 비활성화됐을 때
    opacity: 0.6;                  // 투명하게
    cursor: not-allowed;           // 금지 표시 커서
  }
}

// 크기별 스타일 (작은 것부터 큰 것까지)
.sm { padding: 8px 16px; font-size: 14px; }   // 작은 버튼
.md { padding: 12px 24px; font-size: 16px; }  // 보통 버튼
.lg { padding: 16px 32px; font-size: 18px; }  // 큰 버튼

// 색상별 스타일 (용도에 따라)
.primary { background: #007bff; color: white; }    // 파란색 (주요 버튼)
.secondary { background: #6c757d; color: white; }  // 회색 (보조 버튼)
.danger { background: #dc3545; color: white; }     // 빨간색 (위험 버튼)
```

**🎨 스타일 설명:**
- **padding**: 버튼 안쪽 여백 (위아래 좌우)
- **font-size**: 글자 크기
- **background**: 배경색
- **color**: 글자색
- **transition**: 마우스 올렸을 때 부드럽게 변하는 효과
- **&:disabled**: 버튼이 비활성화됐을 때의 모양

#### 6️⃣단계: Storybook 스토리 작성 (전시관에 버튼 진열하기) 📚

**"이제 만든 버튼을 Storybook에서 구경해볼까요?"** 👀

**Button.stories.tsx 파일을 열고 이 코드를 입력해주세요:**
```typescript
// Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';  // Storybook 타입들
import { Button } from './Button';                       // 우리가 만든 버튼

// 버튼의 기본 정보 설정
const meta: Meta<typeof Button> = {
  title: 'Atoms/Button',           // Storybook에서 보일 위치
  component: Button,               // 전시할 컴포넌트
  parameters: { layout: 'centered' }, // 화면 가운데 배치
};

export default meta;
type Story = StoryObj<typeof meta>;

// 기본 버튼 전시
export const Primary: Story = {
  args: { 
    children: '클릭하세요!',        // 버튼 안 텍스트
    variant: 'primary'            // 파란색 버튼
  },
};

// 모든 종류의 버튼을 한번에 보기
export const AllVariants: Story = {
  render: () => (
    <div style={{ display: 'flex', gap: '8px' }}>  {/* 가로로 나란히 배치 */}
      <Button variant="primary">확인</Button>
      <Button variant="secondary">취소</Button>
      <Button variant="danger">삭제</Button>
    </div>
  ),
};

// 모든 크기의 버튼 보기
export const AllSizes: Story = {
  render: () => (
    <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
      <Button size="sm">작은 버튼</Button>
      <Button size="md">보통 버튼</Button>
      <Button size="lg">큰 버튼</Button>
    </div>
  ),
};

// 비활성화된 버튼
export const Disabled: Story = {
  args: {
    children: '비활성화됨',
    disabled: true
  },
};
```

**📚 Storybook 설명:**
- **meta**: 버튼의 기본 정보 (어디에 표시할지, 어떻게 배치할지)
- **Primary**: 기본 버튼 하나만 보여주기
- **AllVariants**: 색깔별로 모든 버튼 보여주기
- **AllSizes**: 크기별로 모든 버튼 보여주기
- **Disabled**: 비활성화된 버튼 보여주기
- **args**: 버튼에 전달할 정보들
- **render**: 직접 HTML을 그려서 보여주기

#### 7️⃣단계: index.ts 파일 작성 (다른 곳에서 쉽게 가져다 쓰기) 📤

**"마지막으로 다른 사람들이 우리 버튼을 쉽게 쓸 수 있게 해볼까요?"** 🤝

**index.ts 파일을 열고 이 코드를 입력해주세요:**
```typescript
// index.ts
export { Button } from './Button';           // Button 컴포넌트 내보내기
export type { ButtonProps } from './Button'; // ButtonProps 타입 내보내기
```

**📤 내보내기 설명:**
- **export { Button }**: 다른 파일에서 `import { Button } from './Button'`으로 가져다 쓸 수 있어요
- **export type { ButtonProps }**: TypeScript 타입도 다른 곳에서 쓸 수 있게 해줘요

**🎉 완성! 이제 다른 곳에서 이렇게 쓸 수 있어요:**
```typescript
// 다른 파일에서
import { Button } from './components/Atoms/Button';

// 사용하기
<Button variant="primary" size="lg" onClick={() => alert('클릭!')}>  
  안녕하세요!
</Button>
```

**✅ 체크리스트 - 모든 파일이 준비됐나요?**
- ✅ Button.tsx (버튼 동작)
- ✅ Button.module.scss (버튼 스타일)
- ✅ Button.stories.tsx (Storybook 전시)
- ✅ index.ts (내보내기 설정)

**🚀 이제 터미널에서 `npm run storybook`을 실행하고 브라우저에서 확인해보세요!**

### 🚀 개발 효율성 팁 (더 빠르고 똑똑하게 개발하기)

**"어떻게 하면 더 효율적으로 개발할 수 있을까요?"** 🤔

좋은 질문이에요! 경험 많은 개발자들이 사용하는 꿀팁들을 알려드릴게요.

#### 🔄 코드 재사용 극대화 (한 번 만들고 여러 번 쓰기)

**"같은 코드를 계속 복사하고 있나요?"** 😅

**🎨 공통 스타일 만들기**
```scss
// styles/variables.scss - 색깔과 크기를 한 곳에서 관리
$primary-color: #007bff;     // 주요 색깔
$secondary-color: #6c757d;   // 보조 색깔
$border-radius: 4px;         // 모서리 둥글기
$spacing-sm: 8px;            // 작은 여백
$spacing-md: 16px;           // 보통 여백
$spacing-lg: 24px;           // 큰 여백
```

**🛠️ 유틸리티 함수 만들기**
```typescript
// utils/classNames.ts - 클래스 이름 조합을 쉽게
export const cn = (...classes: (string | undefined | null | false)[]) => {
  return classes.filter(Boolean).join(' ');
};

// 사용 예시
const buttonClass = cn(
  styles.button,
  variant && styles[variant],
  size && styles[size],
  disabled && styles.disabled
);
```

**💡 꿀팁:** 색깔이나 크기를 바꿀 때 variables.scss 파일 하나만 수정하면 모든 컴포넌트가 한번에 바뀌어요!

#### 📚 Storybook 적극 활용 (개발자의 전시관)

**"Storybook을 왜 써야 하나요?"** 🤔

**🔍 실시간 확인**
- 코드를 저장하면 바로바로 결과를 볼 수 있어요
- 브라우저 새로고침 필요 없음!
- 여러 상태를 한번에 비교 가능

**🧪 다양한 테스트**
```typescript
// 이런 식으로 모든 경우를 미리 확인할 수 있어요
export const AllStates: Story = {
  render: () => (
    <div>
      <Button>일반 상태</Button>
      <Button disabled>비활성화</Button>
      <Button variant="danger">위험 버튼</Button>
      <Button size="lg">큰 버튼</Button>
    </div>
  ),
};
```

**👥 협업 도구**
- 디자이너: "이 버튼 색깔 좀 더 진하게 해주세요"
- 개발자: "Storybook에서 바로 확인해보세요!"
- 기획자: "이 상태일 때는 어떻게 보이나요?"
- 개발자: "여기 All States 스토리에서 확인하세요!"

#### 📱 반응형 개발 전략 (작은 화면부터!)

**"왜 모바일부터 만들어야 하나요?"** 📱

**1️⃣ 모바일 먼저 (Mobile First) - 가장 중요!**
```scss
// 기본 스타일 = 모바일 스타일
.button {
  padding: 8px 16px;     // 모바일에 맞는 크기
  font-size: 14px;
}

// 태블릿 이상에서만 적용
@media (min-width: 768px) {
  .button {
    padding: 12px 24px;   // 조금 더 크게
    font-size: 16px;
  }
}

// 데스크탑에서만 적용
@media (min-width: 1024px) {
  .button {
    padding: 16px 32px;   // 가장 크게
    font-size: 18px;
  }
}
```

**🎯 왜 모바일부터?**
- 모바일 사용자가 더 많아요 (70% 이상!)
- 작은 화면에서 잘 보이면 큰 화면에서도 잘 보여요
- 반대는 어려워요 (큰 화면용을 작은 화면에 맞추기 힘듦)

**2️⃣ 태블릿 적응**
- 터치하기 좋은 크기로 조정
- 가로/세로 모드 모두 고려

**3️⃣ 데스크탑 확장**
- 마우스 호버 효과 추가
- 더 많은 정보 표시 가능

#### ⚡ 성능 최적화 (빠르고 부드럽게!)

**"웹사이트가 느려요... 어떻게 하죠?"** 😰

**🔄 불필요한 리렌더링 방지**
```typescript
// React.memo로 불필요한 렌더링 막기
const Button = React.memo<ButtonProps>(({ children, variant, onClick }) => {
  return (
    <button className={styles[variant]} onClick={onClick}>
      {children}
    </button>
  );
});

// useMemo로 복잡한 계산 결과 저장하기
const expensiveValue = useMemo(() => {
  return someComplexCalculation(data);
}, [data]); // data가 바뀔 때만 다시 계산
```

**🖼️ 이미지 최적화**
```typescript
// 좋은 예: 적절한 크기와 포맷
<img 
  src="button-icon.webp"     // WebP 포맷 (용량 작음)
  width={24}                 // 실제 사용할 크기
  height={24}
  alt="버튼 아이콘"
  loading="lazy"             // 필요할 때만 로드
/>

// 나쁜 예: 큰 이미지를 작게 표시
<img 
  src="huge-image-4000x4000.jpg"  // 4000x4000 이미지를
  width={24}                       // 24x24로 표시 (비효율적!)
  height={24}
/>
```

**📦 CSS 번들 크기 최소화**
```scss
// 좋은 예: 필요한 스타일만
.button {
  padding: 12px 24px;
  background: $primary-color;
}

// 나쁜 예: 사용하지 않는 복잡한 스타일
.button {
  padding: 12px 24px;
  background: linear-gradient(45deg, #ff0000, #00ff00, #0000ff, #ffff00);
  box-shadow: 0 0 10px rgba(0,0,0,0.5), inset 0 0 20px rgba(255,255,255,0.3);
  transform: perspective(1000px) rotateX(10deg) rotateY(5deg);
  // ... 너무 복잡한 스타일들
}
```

**💡 성능 체크 방법:**
1. 브라우저 개발자 도구 → Network 탭에서 로딩 시간 확인
2. Lighthouse로 성능 점수 측정
3. 실제 모바일 기기에서 테스트

## 🧩 컴포넌트 개발 가이드 (레고 블록 조립하기)

**"컴포넌트를 어떻게 나누고 조합해야 할까요?"** 🤔

컴포넌트는 레고 블록과 같아요! 작은 블록들을 조합해서 큰 작품을 만드는 거죠.

### 🔬 Atomic Design 원칙 (과학적 접근법)

**"왜 원자, 분자, 유기체라고 부르나요?"** ⚛️

화학에서 원자가 모여 분자를 만들고, 분자가 모여 복잡한 물질을 만드는 것처럼, 웹 컴포넌트도 같은 방식으로 조합해요!

#### ⚛️ Atoms (원자) - 가장 작은 단위

**"더 이상 쪼갤 수 없는 가장 기본적인 요소들"**

**🔍 특징:**
- HTML의 기본 요소들 (button, input, img 등)
- 혼자서도 의미가 있어요
- 다른 컴포넌트의 재료가 되어요

**📝 예시:**
```typescript
// Button (버튼 원자)
<Button variant="primary">클릭하세요</Button>

// Input (입력창 원자)
<Input placeholder="이름을 입력하세요" />

// Label (라벨 원자)
<Label>사용자 이름</Label>

// Icon (아이콘 원자)
<Icon name="search" size={24} />
```

**💡 Atoms를 만들 때 주의사항:**
- 최대한 단순하게 만들어요
- 재사용 가능하게 설계해요
- 다양한 상황에서 쓸 수 있게 해요

#### 🧪 Molecules (분자) - 기능을 가진 조합

**"여러 원자가 모여서 하나의 기능을 수행하는 단위"**

**🔍 특징:**
- 2개 이상의 Atoms가 결합
- 특정한 목적/기능이 있어요
- 사용자가 실제로 상호작용하는 단위

**📝 예시:**
```typescript
// SearchBox (검색창 분자) = Input + Button
<SearchBox 
  placeholder="검색어를 입력하세요"
  onSearch={(query) => console.log(query)}
/>

// FormField (폼 필드 분자) = Label + Input + ErrorMessage
<FormField 
  label="이메일"
  type="email"
  error="올바른 이메일을 입력해주세요"
/>

// Card (카드 분자) = Image + Title + Description + Button
<Card 
  image="product.jpg"
  title="상품명"
  description="상품 설명"
  onButtonClick={() => {}}
/>
```

**💡 Molecules를 만들 때 주의사항:**
- 하나의 명확한 목적을 가져야 해요
- 너무 복잡하게 만들지 마세요
- 다른 곳에서도 쓸 수 있게 범용적으로 만들어요

#### 🦠 Organisms (유기체) - 페이지의 큰 섹션

**"Molecules와 Atoms가 모여서 만든 복잡하고 완전한 구조"**

**🔍 특징:**
- 페이지의 독립적인 영역
- 여러 기능을 포함해요
- 사용자가 인식하는 "구역"

**📝 예시:**
```typescript
// Header (헤더 유기체) = Logo + Navigation + SearchBox + UserMenu
<Header 
  logo={<Logo />}
  navigation={<Navigation items={menuItems} />}
  searchBox={<SearchBox onSearch={handleSearch} />}
  userMenu={<UserMenu user={currentUser} />}
/>

// ProductList (상품 목록 유기체) = Title + Filter + Cards + Pagination
<ProductList 
  title="인기 상품"
  products={products}
  onFilter={handleFilter}
  onPageChange={handlePageChange}
/>

// Footer (푸터 유기체) = CompanyInfo + Links + SocialMedia + Copyright
<Footer 
  companyInfo={companyData}
  links={footerLinks}
  socialMedia={socialLinks}
/>
```

**💡 Organisms를 만들 때 주의사항:**
- 페이지의 의미 있는 섹션이어야 해요
- 독립적으로 동작할 수 있어야 해요
- 너무 크게 만들지 마세요 (관리하기 어려워져요)

**🎯 실제 예시로 이해하기:**

```
🏠 웹사이트 = 집
├── 🏢 Header (Organism) = 집의 현관
│   ├── 🏷️ Logo (Atom) = 집 이름표
│   ├── 🧭 Navigation (Molecule) = 안내판
│   └── 🔍 SearchBox (Molecule) = 우편함
├── 📦 ProductList (Organism) = 거실
│   ├── 🏷️ Title (Atom) = 거실 이름표
│   ├── 🎛️ Filter (Molecule) = 리모컨
│   └── 🃏 ProductCard (Molecule) = 가구들
└── 🦶 Footer (Organism) = 집의 지하실
    ├── 📞 ContactInfo (Molecule) = 연락처
    └── 🔗 Links (Molecule) = 관련 링크들
```

**✅ 올바른 분류 체크리스트:**

**Atom인지 확인:**
- ✅ 더 이상 쪼갤 수 없나요?
- ✅ 혼자서도 의미가 있나요?
- ✅ 다른 곳에서도 재사용할 수 있나요?

**Molecule인지 확인:**
- ✅ 여러 Atom이 모여 있나요?
- ✅ 하나의 기능을 수행하나요?
- ✅ 사용자가 상호작용할 수 있나요?

**Organism인지 확인:**
- ✅ 페이지의 독립적인 영역인가요?
- ✅ 여러 기능을 포함하고 있나요?
- ✅ 사용자가 "구역"으로 인식하나요?

### 🛠️ 새 컴포넌트 만들기 (단계별 가이드)

**"새로운 컴포넌트를 어떻게 만들어야 할까요?"** 🤔

차근차근 따라해보세요! 실수하지 않는 확실한 방법이에요.

**📋 체크리스트 (하나씩 체크하면서 진행하세요!)**

- [ ] **1단계**: 적절한 Atomic Design 레벨 결정 🔬
- [ ] **2단계**: 컴포넌트 폴더 생성 📁
- [ ] **3단계**: TypeScript 인터페이스 정의 📐
- [ ] **4단계**: 컴포넌트 구현 ⚙️
- [ ] **5단계**: 스타일 작성 (모바일 우선) 🎨
- [ ] **6단계**: Storybook 스토리 작성 📚
- [ ] **7단계**: index.ts 파일로 export 📤
- [ ] **8단계**: 테스트 및 확인 ✅

**💡 각 단계별 상세 가이드는 위의 "효율적인 코드 작성 가이드" 섹션을 참고하세요!**

**🎯 실제 예시:**
```bash
# 예시: 새로운 Card 컴포넌트 만들기

# 1. 폴더 구조 만들기
src/components/Molecules/Card/
├── Card.tsx              # 컴포넌트 로직
├── Card.module.scss      # 스타일
├── Card.stories.tsx      # Storybook 스토리
└── index.ts             # 내보내기

# 2. 완성 후 다른 곳에서 사용하기
import { Card } from './components/Molecules/Card';

<Card 
  title="상품명"
  description="상품 설명"
  image="product.jpg"
  onButtonClick={() => alert('클릭!')}
/>
```

### 🎨 스타일링 가이드 (예쁘게 꾸미는 방법)

**"어떻게 하면 일관성 있고 예쁜 스타일을 만들 수 있을까요?"** ✨

#### 📦 CSS Modules 사용 (스타일 충돌 방지)

**"CSS Modules가 뭔가요?"** 🤔
- 각 컴포넌트의 스타일을 독립적으로 관리하는 방법
- 클래스명이 겹쳐도 문제없어요!
- 컴포넌트별로 스타일이 격리되어 안전해요

**📝 사용 방법:**
```scss
/* Card.module.scss */
.card {
  background: white;
  border-radius: 8px;
  padding: 16px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.title {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 8px;
}

.description {
  color: #666;
  line-height: 1.5;
}
```

```typescript
// Card.tsx
import styles from './Card.module.scss';

const Card = ({ title, description }) => {
  return (
    <div className={styles.card}>        {/* .card 클래스 적용 */}
      <h3 className={styles.title}>{title}</h3>
      <p className={styles.description}>{description}</p>
    </div>
  );
};
```

**💡 CSS Modules의 장점:**
- ✅ 클래스명 충돌 걱정 없음
- ✅ 컴포넌트별 스타일 독립성
- ✅ 빌드 시 자동으로 고유한 클래스명 생성
- ✅ 사용하지 않는 스타일 자동 제거

#### 📱 반응형 디자인 (모든 기기에서 예쁘게)

**"모바일, 태블릿, 데스크탑에서 모두 잘 보이게 하려면?"** 📱💻

**🎯 모바일 우선 접근법 (Mobile First)**
```scss
// Card.module.scss
.card {
  /* 📱 모바일 기본 스타일 (가장 작은 화면) */
  padding: 16px;           // 작은 여백
  font-size: 14px;         // 작은 글자
  margin: 8px;             // 작은 마진
  border-radius: 4px;      // 작은 둥근 모서리
}

/* 📱➡️🖥️ 태블릿 이상에서 적용 (768px 이상) */
@media (min-width: 768px) {
  .card {
    padding: 24px;         // 조금 더 큰 여백
    font-size: 16px;       // 조금 더 큰 글자
    margin: 12px;          // 조금 더 큰 마진
    border-radius: 6px;    // 조금 더 둥근 모서리
  }
}

/* 🖥️ 데스크탑에서만 적용 (1024px 이상) */
@media (min-width: 1024px) {
  .card {
    padding: 32px;         // 가장 큰 여백
    font-size: 18px;       // 가장 큰 글자
    margin: 16px;          // 가장 큰 마진
    border-radius: 8px;    // 가장 둥근 모서리
    
    /* 🖱️ 데스크탑에서만 호버 효과 */
    &:hover {
      transform: translateY(-2px);  // 살짝 위로 올라가는 효과
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    }
  }
}
```

**🔍 브레이크포인트 설명:**
- **768px 미만**: 📱 모바일 (스마트폰)
- **768px ~ 1023px**: 📱 태블릿 (아이패드 등)
- **1024px 이상**: 🖥️ 데스크탑 (노트북, 모니터)

**💡 반응형 디자인 팁:**
```scss
/* ✅ 좋은 예: 점진적 향상 */
.button {
  /* 모바일: 터치하기 쉬운 크기 */
  padding: 12px 16px;
  font-size: 16px;
  
  /* 태블릿: 조금 더 여유롭게 */
  @media (min-width: 768px) {
    padding: 14px 20px;
  }
  
  /* 데스크탑: 마우스 호버 효과 추가 */
  @media (min-width: 1024px) {
    padding: 16px 24px;
    
    &:hover {
      background-color: darken($primary-color, 10%);
    }
  }
}

/* ❌ 나쁜 예: 데스크탑 우선 */
.button {
  padding: 16px 24px;  /* 데스크탑 크기를 기본으로 */
  
  @media (max-width: 1023px) {
    padding: 12px 16px;  /* 작은 화면에서 줄이기 (어려움!) */
  }
}
```

**🎨 색상과 간격 일관성 유지:**
```scss
// styles/variables.scss - 공통 변수 정의
$primary-color: #007bff;
$secondary-color: #6c757d;
$success-color: #28a745;
$danger-color: #dc3545;

$spacing-xs: 4px;
$spacing-sm: 8px;
$spacing-md: 16px;
$spacing-lg: 24px;
$spacing-xl: 32px;

$border-radius-sm: 4px;
$border-radius-md: 6px;
$border-radius-lg: 8px;

// 사용 예시
.card {
  padding: $spacing-md;
  margin: $spacing-sm;
  border-radius: $border-radius-md;
  background: $primary-color;
}
```

## 🌟 주요 기능 (이 프로젝트의 특별한 점들)

**"이 프로젝트에는 어떤 멋진 기능들이 있나요?"** ✨

### 🔍 애니메이션 검색 아이콘 (살아있는 아이콘!)

**"검색 아이콘이 움직인다고요?"** 😮

네! 정말 멋진 기능이에요. 사용자의 시선을 끌고 웹사이트를 더 생동감 있게 만들어줘요.

**🎬 어떻게 동작하나요?**
- Header 컴포넌트에 구현된 순환 애니메이션
- `search` → `search_gra` → `search_ai` 아이콘 순서로 계속 변경
- 0.5초마다 자동으로 다음 아이콘으로 전환
- 부드러운 fade-in/fade-out 효과로 자연스럽게 변화

**🔧 기술적 구현:**
```typescript
// Header.tsx에서 구현된 애니메이션 로직
const [currentSearchIcon, setCurrentSearchIcon] = useState<'search' | 'search_gra' | 'search_ai'>('search');
const [iconOpacity, setIconOpacity] = useState(1);

useEffect(() => {
  const interval = setInterval(() => {
    setIconOpacity(0); // 페이드 아웃
    
    setTimeout(() => {
      setCurrentSearchIcon(prev => {
        if (prev === 'search') return 'search_gra';
        if (prev === 'search_gra') return 'search_ai';
        return 'search';
      });
      setIconOpacity(1); // 페이드 인
    }, 150);
  }, 500);

  return () => clearInterval(interval);
}, []);
```

**🎨 CSS 트랜지션:**
```scss
// Header.module.scss
.rightTop .icon {
  transition: opacity 0.3s ease-in-out; // 부드러운 투명도 변화
}
```

**💡 왜 이 기능이 좋은가요?**
- ✅ 사용자 관심 유도 (시각적 매력)
- ✅ 모던한 웹사이트 느낌
- ✅ AI 기능을 암시하는 UX
- ✅ 브랜드 차별화 요소

### 📱 반응형 헤더 (모든 기기에서 완벽하게!)

**"어떤 기기에서 봐도 예쁘게 보인다고요?"** 📱💻

맞아요! 스마트폰부터 대형 모니터까지 모든 화면에서 완벽하게 보여요.

**🔧 기술적 특징:**
- **CSS Grid와 Flexbox 활용**: 유연하고 강력한 레이아웃
- **동적 스타일 적용**: 화면 크기에 따라 자동 조정
- **터치 친화적**: 모바일에서 터치하기 쉬운 크기
- **중앙일보 스타일**: 깔끔하고 전문적인 디자인
- **로고, 네비게이션, 검색 기능**: 모든 핵심 요소 포함

**📱 모바일 (768px 미만)**
```scss
.header {
  padding: 12px 16px;        // 작은 여백
  
  .logo {
    font-size: 18px;         // 작은 로고
  }
  
  .rightTop {
    gap: 12px;               // 아이콘 간격 좁게
    
    .icon {
      width: 20px;           // 작은 아이콘
      height: 20px;
    }
  }
}
```

**🖥️ 데스크탑 (1024px 이상)**
```scss
@media (min-width: 1024px) {
  .header {
    padding: 16px 32px;      // 큰 여백
    
    .logo {
      font-size: 24px;       // 큰 로고
    }
    
    .rightTop {
      gap: 20px;             // 아이콘 간격 넓게
      
      .icon {
        width: 24px;         // 큰 아이콘
        height: 24px;
        
        &:hover {
          transform: scale(1.1); // 호버 효과
        }
      }
    }
  }
}
```

**💡 반응형 디자인의 장점:**
- ✅ 모든 기기에서 최적의 사용자 경험
- ✅ SEO 향상 (구글이 모바일 친화적 사이트 선호)
- ✅ 접근성 개선 (다양한 사용자 고려)
- ✅ 유지보수 효율성 (하나의 코드로 모든 기기 대응)

## 🛠️ 개발 도구 (개발자의 든든한 동반자들)

**"이 프로젝트는 어떤 도구들로 만들어졌나요?"** 🔧

최신 기술과 검증된 도구들로 구성되어 있어요!

### 📚 Storybook (컴포넌트의 전시관)

**"Storybook이 뭐하는 도구인가요?"** 🤔

컴포넌트를 개발하고 테스트하는 최고의 도구예요! 마치 컴포넌트들의 전시관 같아요.

**🎯 주요 기능:**
- **실시간 미리보기**: 코드 저장하면 바로 결과 확인
- **독립적 개발**: 페이지 전체를 만들지 않고도 컴포넌트만 테스트
- **다양한 상태 시뮬레이션**: 모든 경우의 수를 미리 확인
- **협업 도구**: 디자이너, 기획자와 소통할 때 유용
- **문서화 자동 생성**: 컴포넌트 사용법이 자동으로 문서화

**📝 실제 사용 예시:**
```typescript
// Button.stories.tsx
export const AllStates: Story = {
  render: () => (
    <div style={{ display: 'flex', gap: '16px' }}>
      <Button variant="primary">일반 상태</Button>
      <Button variant="primary" disabled>비활성화</Button>
      <Button variant="danger">위험 버튼</Button>
      <Button variant="secondary" size="lg">큰 버튼</Button>
    </div>
  ),
};
```

**💡 Storybook의 장점:**
- ✅ 빠른 개발 속도
- ✅ 버그 사전 발견
- ✅ 컴포넌트 문서화 자동화
- ✅ 팀 협업 효율성 증대

### 🔷 TypeScript (타입의 마법사)

**"TypeScript를 왜 사용하나요?"** 🤔

JavaScript의 슈퍼 히어로 버전이에요! 코딩 실수를 미리 잡아주는 똑똑한 도우미죠.

**🛡️ 타입 안전성 보장:**
```typescript
// ❌ JavaScript: 런타임에 에러 발생
function greet(name) {
  return "Hello, " + name.toUppercase(); // 오타! (toUpperCase가 맞음)
}

greet(123); // 숫자를 넘겨도 에러 안남

// ✅ TypeScript: 개발 중에 에러 발견
function greet(name: string): string {
  return "Hello, " + name.toUppercase(); // 🚨 에러! toUppercase는 없는 메서드
}

greet(123); // 🚨 에러! string 타입이어야 함
```

**🎯 개발 시 오류 사전 방지:**
```typescript
// 컴포넌트 props 타입 정의
interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  onClick?: () => void;
}

// 잘못된 props 사용 시 즉시 에러 표시
<Button variant="wrong-type">  {/* 🚨 에러! 허용되지 않는 variant */}
  클릭하세요
</Button>
```

**💡 TypeScript의 장점:**
- ✅ 개발 중 실시간 에러 검출
- ✅ 자동완성 기능 향상
- ✅ 리팩토링 안전성
- ✅ 코드 가독성 향상
- ✅ 팀 협업 시 의사소통 명확화

### 🎨 SCSS (CSS의 진화형)

**"SCSS가 일반 CSS와 뭐가 다른가요?"** 🤔

CSS에 프로그래밍 기능을 추가한 강력한 도구예요!

**🔧 주요 기능들:**

**1️⃣ 변수 사용:**
```scss
// 색상과 크기를 변수로 관리
$primary-color: #007bff;
$secondary-color: #6c757d;
$border-radius: 8px;
$spacing: 16px;

.button {
  background: $primary-color;     // 변수 사용
  border-radius: $border-radius;
  padding: $spacing;
}

.card {
  border: 1px solid $secondary-color;
  border-radius: $border-radius;  // 같은 변수 재사용
}
```

**2️⃣ 중첩 규칙 (Nesting):**
```scss
// SCSS: 구조적이고 읽기 쉬움
.header {
  background: white;
  padding: 16px;
  
  .logo {
    font-size: 24px;
    font-weight: bold;
    
    &:hover {              // & = 부모 선택자
      color: $primary-color;
    }
  }
  
  .navigation {
    display: flex;
    gap: 20px;
    
    .nav-item {
      padding: 8px 16px;
      
      &.active {
        background: $primary-color;
        color: white;
      }
    }
  }
}
```

**3️⃣ 믹스인 (Mixins) - 재사용 가능한 스타일:**
```scss
// 자주 사용하는 스타일을 믹스인으로 정의
@mixin button-style($bg-color, $text-color) {
  padding: 12px 24px;
  border: none;
  border-radius: $border-radius;
  background: $bg-color;
  color: $text-color;
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }
}

// 믹스인 사용
.primary-button {
  @include button-style($primary-color, white);
}

.secondary-button {
  @include button-style($secondary-color, white);
}
```

**4️⃣ 모듈화된 스타일 관리:**
```scss
// styles/abstracts/_variables.scss
$colors: (
  primary: #007bff,
  secondary: #6c757d,
  success: #28a745,
  danger: #dc3545
);

// styles/abstracts/_mixins.scss
@mixin responsive($breakpoint) {
  @if $breakpoint == mobile {
    @media (max-width: 767px) { @content; }
  }
  @if $breakpoint == tablet {
    @media (min-width: 768px) and (max-width: 1023px) { @content; }
  }
  @if $breakpoint == desktop {
    @media (min-width: 1024px) { @content; }
  }
}

// 컴포넌트에서 사용
.card {
  padding: 16px;
  
  @include responsive(tablet) {
    padding: 24px;
  }
  
  @include responsive(desktop) {
    padding: 32px;
  }
}
```

**💡 SCSS의 장점:**
- ✅ 코드 재사용성 극대화
- ✅ 유지보수 효율성
- ✅ 가독성 향상
- ✅ 대규모 프로젝트 관리 용이
- ✅ CSS보다 강력한 기능

### 🔍 코드 품질 도구 (완벽한 코드를 위한 도우미들)

**"코드 품질은 어떻게 관리하나요?"** 🤔

자동화된 도구들이 코드를 깔끔하고 일관성 있게 유지해줘요!

**🔧 ESLint (코드 스타일 검사관)**
- 코딩 규칙 위반 사항 자동 검출
- 잠재적 버그 미리 발견
- 팀 내 코딩 스타일 통일

**✨ Prettier (코드 포맷터)**
- 코드 자동 정렬 및 포맷팅
- 일관된 코드 스타일 유지
- 저장할 때마다 자동 적용

**🔷 TypeScript (타입 안정성)**
- 컴파일 타임 에러 검출
- 더 나은 개발자 경험
- 안전한 리팩토리

## 빌드 및 배포

### 개발 빌드

```bash
npm run build
```

### Storybook 빌드

```bash
npm run build-storybook
```

## 문제 해결

### 자주 발생하는 문제

1. **포트 충돌**: 다른 애플리케이션이 3010 포트를 사용 중인 경우
   - 해결: 다른 포트 사용 또는 기존 프로세스 종료

2. **스타일이 적용되지 않는 경우**
   - CSS Modules 클래스명 확인
   - SCSS 파일 경로 확인

3. **컴포넌트가 렌더링되지 않는 경우**
   - TypeScript 타입 오류 확인
   - import/export 경로 확인

## 추가 리소스

- [React 공식 문서](https://react.dev/)
- [Storybook 공식 문서](https://storybook.js.org/)
- [TypeScript 공식 문서](https://www.typescriptlang.org/)
- [SCSS 가이드](https://sass-lang.com/)

## 기여하기

1. 새로운 기능이나 버그 수정을 위한 브랜치 생성
2. 코드 작성 및 테스트
3. Storybook에서 컴포넌트 확인
4. 코드 리뷰 요청

---

이 가이드는 비개발자도 프로젝트를 이해하고 기여할 수 있도록 작성되었습니다. 추가 질문이나 개선 사항이 있다면 언제든 문의해 주세요.